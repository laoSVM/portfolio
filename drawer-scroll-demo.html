<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Drawer Scroll Effect — Themed</title>
  <link rel="stylesheet" href="css/main.css" />
  <style>
    /* Reset and base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    /* Use site theme variables, but keep cursor visible on this standalone page */
    body {
      font-family: var(--font-primary);
      background: var(--background);
      color: var(--text-primary);
      overflow-x: hidden;
      overflow-y: auto;
      cursor: auto !important;
    }
    a, button, input, textarea, select, [role="button"], [onclick] {
      cursor: auto !important;
    }

    /* top progress bar (fix for missing element in reference) */
    #progressBar {
      position: fixed;
      top: 0; left: 0;
      width: 0; height: 3px;
      background: var(--primary);
      z-index: var(--z-sticky);
    }

    /* creates scrollable space */
    .page-container { height: 600vh; position: relative; }

    /* fixed viewport wrapper that holds absolute sections */
    .sections-wrapper {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100vh;
      pointer-events: none; /* let page scrolling pass through; each section itself allows interactions */
    }

    /* each full-screen layer */
    .drawer-section {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto; /* allow clicks inside */
      transition: transform 320ms cubic-bezier(.2,.9,.2,1);
      will-change: transform;
      /* subtle themed shadow */
      box-shadow: var(--shadow-lg) inset 0 0 0 rgba(0,0,0,0);
    }


    /* background layer for first section */
    .drawer-section--has-bg { position: relative; }
    .drawer-section--has-bg .drawer-bg {
      position: absolute; inset: 0; overflow: hidden; z-index: 0;
    }
    .drawer-hero-canvas {
      position: absolute; inset: 0; width: 100%; height: 100%; display: block; pointer-events: none;
    }
    /* reuse site's grid animation via hero__lines, ensure it sits above canvas */
    .drawer-section--has-bg .hero__lines { 
      pointer-events: none; 
      z-index: 1; 
      opacity: 0.6;
      position: absolute;
      top: -50px;
      left: -50px;
      width: calc(100% + 100px);
      height: calc(100% + 100px);
      background-image: 
        linear-gradient(90deg, var(--border) 1px, transparent 1px),
        linear-gradient(var(--border) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: moveLines 20s linear infinite;
    }

    @keyframes moveLines {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }

    .drawer-section.hero {
      position: relative;
      align-items: flex-start;    /* vertical alignment: top */
      justify-content: flex-start; /* horizontal alignment: left */
    }

    /* stacking order (later sections above earlier ones) and themed backgrounds */
    .drawer-section:nth-child(1){ z-index: 1; background: var(--background); }
    .drawer-section:nth-child(2){ z-index: 2; background: var(--accent); border-top-left-radius: var(--radius-3xl); border-top-right-radius: var(--radius-3xl); overflow: hidden; }
    .drawer-section:nth-child(3){ z-index: 3; background: var(--surface); border-top-left-radius: var(--radius-3xl); border-top-right-radius: var(--radius-3xl); overflow: hidden; }
    .drawer-section:nth-child(4){ z-index: 4; background: var(--accent-light); border-top-left-radius: var(--radius-3xl); border-top-right-radius: var(--radius-3xl); overflow: hidden; }
    .drawer-section:nth-child(5){ z-index: 5; background: var(--background); border-top-left-radius: var(--radius-3xl); border-top-right-radius: var(--radius-3xl); overflow: hidden; }

    /* content area — themed text colors; this is the only thing that fades */
    .section-content {
      text-align: center; color: var(--text-primary); padding: 0 6vw;
      position: relative; z-index: 2;
      transition: opacity 260ms linear;
      will-change: opacity;
      width: 100%;
      max-width: 100%;
    }

    .section-content h1 { font-size: clamp(2.2rem, 7vw, 4.4rem); margin-bottom: 0.75rem; line-height: 1.05; }
    .section-content p { font-size: clamp(1rem, 2vw, 1.3rem); opacity: 0.95; margin-bottom: 1.25rem; font-weight: 400; color: var(--text-secondary); }

    .cta-button {
      display: inline-block; padding: 0.9rem 2rem;
      background: var(--primary); border: 2px solid var(--primary);
      border-radius: 40px; color: var(--white); text-decoration: none; font-weight: 600;
      transition: transform var(--transition-base), box-shadow var(--transition-base), background var(--transition-base);
      box-shadow: var(--shadow-md);
    }
    .cta-button:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); background: var(--primary-dark); }

    .scroll-indicator { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%); z-index: 300; color: var(--text-secondary); text-align:center; transition: opacity 220ms linear; }
    .scroll-indicator svg{ width: 28px; height: 28px; fill: var(--text-secondary); opacity: 0.75; }
    .scroll-text { font-size: 0.9rem; opacity: 0.75; margin-top: 0.45rem; }

    .nav-dots { position: fixed; right: 2rem; top: 50%; transform: translateY(-50%); z-index: 300; display:flex; flex-direction: column; gap: 0.9rem; }
    .nav-dot { width: 12px; height: 12px; border-radius: 50%; background: var(--surface); border: 2px solid var(--border); cursor: pointer; transition: all 180ms ease; }
    .nav-dot.active { background: var(--primary); border-color: var(--primary); transform: scale(1.2); }
    
    /* Top navigation bar */
    .hero-nav {
      position: absolute;
      top: 0;
      left: 6vw;
      right: 6vw;
      height: var(--nav-height);
      z-index: 10;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 88vw;
      margin-left: 0;
    }
    
    .hero-nav .nav-text {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.1rem;
    }
    
    .hero-nav .nav-links {
      display: flex;
      gap: 2rem;
    }
    
    .hero-nav .nav-link {
      position: relative;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.95rem;
      padding: var(--space-xs) 0;
      transition: color var(--transition-base);
    }
    
    .hero-nav .nav-link::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--primary);
      transition: width var(--transition-base);
    }
    
    .hero-nav .nav-link:hover {
      color: var(--primary);
    }
    
    .hero-nav .nav-link:hover::after {
      width: 100%;
    }

    /* Giant headline and content for first section */
    .hero-header {
      margin-top: 24vh;
      max-width: 88vw;
      text-align: left;
    }
    .hero-headline {
      font-weight: 800;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-primary);
      line-height: 0.9;
      width: 75vw; /* cover ~3/4 of screen width */
      font-size: clamp(4rem, 12vw, 18rem);
      white-space: nowrap;
      margin: 0;
      padding: 0;
      text-indent: -0.05em; /* Optical adjustment for large fonts */
    }
    .hero-header p {
      margin-top: var(--space-sm);
      font-size: clamp(1rem, 2vw, 1.25rem);
      color: var(--text-secondary);
      max-width: 60vw;
    }
    
    @media (max-width: 768px) {
      .nav-dots { right: 1rem; }
      .section-content { padding: 1.25rem; }
      .hero-header { left: 5vw; top: 10vh; }
      .hero-headline { width: 86vw; font-size: clamp(3rem, 16vw, 10rem); }
    }
  </style>
</head>
<body>
  <div id="progressBar"></div>
  <div class="page-container"></div>

  <div class="sections-wrapper" id="sectionsWrapper">
    <div class="drawer-section drawer-section--has-bg hero" data-section="0">
      <!-- Background layer -->
      <div class="drawer-bg" aria-hidden="true">
        <canvas id="drawerHeroCanvas" class="drawer-hero-canvas"></canvas>
        <div class="hero__lines" aria-hidden="true"></div>
      </div>
      <!-- Fixed navigation bar (does not fade) -->
      <div class="hero-nav">
        <div class="nav-text">Portfolio</div>
        <div class="nav-links">
          <a href="https://github.com" class="nav-link">github</a>
          <a href="#" class="nav-link">about</a>
          <a href="#" class="nav-link">contact</a>
        </div>
      </div>
      

      
      <!-- Content that fades on scroll -->
      <div class="section-content">
        <div class="hero-header">
          <div class="hero-headline">EXPERIENCE</div>
          <p>Experience the future of web design with smooth, engaging scroll interactions that tell your story one layer at a time.</p>
        </div>
      </div>
    </div>

    <div class="drawer-section" data-section="1">
      <div class="section-content">
        <h1>Crafted Experiences</h1>
        <p>Every scroll reveals a new chapter. We build immersive digital experiences that captivate and convert your audience.</p>
        <a href="#" class="cta-button">Learn How</a>
      </div>
    </div>

    <div class="drawer-section" data-section="2">
      <div class="section-content">
        <h1>Performance Matters</h1>
        <p>Lightning-fast load times meet stunning visuals. Our solutions are optimized for speed without compromising on beauty.</p>
        <a href="#" class="cta-button">See Results</a>
      </div>
    </div>

    <div class="drawer-section" data-section="3">
      <div class="section-content">
        <h1>Built to Scale</h1>
        <p>From startups to enterprises, our architecture grows with your ambitions. Robust, reliable, and ready for tomorrow.</p>
        <a href="#" class="cta-button">Start Building</a>
      </div>
    </div>

    <div class="drawer-section" data-section="4">
      <div class="section-content">
        <h1>Let's Connect</h1>
        <p>Ready to transform your digital presence? Let's create something extraordinary together.</p>
        <a href="#" class="cta-button">Get In Touch</a>
      </div>
    </div>
  </div>

  <div class="scroll-indicator" id="scrollIndicator">
    <svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>
    <div class="scroll-text">Scroll to explore</div>
  </div>

  <div class="nav-dots" id="navDots"></div>

  <script>
    // Lightweight particle system for the first section only (themed)
    class DrawerParticleSystem {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particles = [];
        this.mousePosition = { x: 0, y: 0 };
        this.primaryHex = this.getCssVar('--primary') || '#8B4513';
        this.primaryRgb = this.hexToRgb(this.primaryHex) || { r: 139, g: 69, b: 19 };

        this.resize();
        this.setupCanvas();
        this.createParticles();
        this.bindEvents();
        this.animate();
      }

      getCssVar(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }

      hexToRgb(hex) {
        const normalized = hex.startsWith('#') ? hex.slice(1) : hex;
        if (normalized.length === 3) {
          const r = parseInt(normalized[0] + normalized[0], 16);
          const g = parseInt(normalized[1] + normalized[1], 16);
          const b = parseInt(normalized[2] + normalized[2], 16);
          return { r, g, b };
        }
        if (normalized.length === 6) {
          const r = parseInt(normalized.slice(0, 2), 16);
          const g = parseInt(normalized.slice(2, 4), 16);
          const b = parseInt(normalized.slice(4, 6), 16);
          return { r, g, b };
        }
        return null;
      }

      setupCanvas() {
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        this.ctx.lineWidth = 0;
        this.ctx.strokeStyle = 'transparent';
      }

      resize() {
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = Math.max(1, Math.round(rect.width));
        this.canvas.height = Math.max(1, Math.round(rect.height));
      }

      bindEvents() {
        window.addEventListener('resize', () => {
          this.resize();
          this.particles = [];
          this.createParticles();
        });

        document.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          this.mousePosition.x = e.clientX - rect.left;
          this.mousePosition.y = e.clientY - rect.top;
        });
      }

      createParticles() {
        const area = this.canvas.width * this.canvas.height;
        const count = Math.floor(area / 20000);
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: Math.random() * 1.5 + 0.8,
            opacity: Math.random() * 0.3 + 0.3,
            baseX: 0,
            baseY: 0
          });
        }
        this.particles.forEach(p => { p.baseX = p.x; p.baseY = p.y; });
      }

      animate() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // update and draw particles
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const dx = this.mousePosition.x - p.x;
          const dy = this.mousePosition.y - p.y;
          const dist = Math.hypot(dx, dy);
          const maxD = 100;
          if (dist < maxD) {
            const force = (maxD - dist) / maxD;
            const angle = Math.atan2(dy, dx);
            p.vx -= Math.cos(angle) * force * 0.5;
            p.vy -= Math.sin(angle) * force * 0.5;
          }
          p.vx += (p.baseX - p.x) * 0.01;
          p.vy += (p.baseY - p.y) * 0.01;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0) p.x = this.canvas.width;
          if (p.x > this.canvas.width) p.x = 0;
          if (p.y < 0) p.y = this.canvas.height;
          if (p.y > this.canvas.height) p.y = 0;

          ctx.save();
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = this.primaryHex;
          ctx.beginPath();
          ctx.arc(Math.round(p.x), Math.round(p.y), p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // draw connections
        for (let i = 0; i < this.particles.length; i++) {
          for (let j = i + 1; j < this.particles.length; j++) {
            const a = this.particles[i];
            const b = this.particles[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const d = Math.hypot(dx, dy);
            if (d < 100) {
              const alpha = 0.1 * (1 - d / 100);
              this.ctx.strokeStyle = `rgba(${this.primaryRgb.r}, ${this.primaryRgb.g}, ${this.primaryRgb.b}, ${alpha})`;
              this.ctx.beginPath();
              this.ctx.moveTo(a.x, a.y);
              this.ctx.lineTo(b.x, b.y);
              this.ctx.stroke();
            }
          }
        }

        requestAnimationFrame(() => this.animate());
      }
    }

    const sections = Array.from(document.querySelectorAll('.drawer-section'));
    const navDotsContainer = document.getElementById('navDots');
    const scrollIndicator = document.getElementById('scrollIndicator');
    const progressBar = document.getElementById('progressBar');

    const TOTAL_SECTIONS = sections.length;
    let SECTION_HEIGHT = window.innerHeight * 1.2;

    // create nav dots
    sections.forEach((s, i) => {
      const dot = document.createElement('div');
      dot.className = 'nav-dot' + (i === 0 ? ' active' : '');
      dot.addEventListener('click', () => {
        window.scrollTo({ top: i * SECTION_HEIGHT, behavior: 'smooth' });
      });
      navDotsContainer.appendChild(dot);
    });
    const navDots = Array.from(document.querySelectorAll('.nav-dot'));

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function handleScroll() {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      const scrollProgress = maxScroll > 0 ? clamp(scrollTop / maxScroll, 0, 1) : 0;
      if (progressBar) progressBar.style.width = `${scrollProgress * 100}%`;

      const currentSectionFloat = scrollTop / SECTION_HEIGHT;
      navDots.forEach((dot, i) => dot.classList.toggle('active', i === Math.round(currentSectionFloat)));

      // Reset all contents to visible by default (we only fade specific previous content during slide)
      sections.forEach((s) => {
        const c = s.querySelector('.section-content');
        if (c) c.style.opacity = '1';
      });

      sections.forEach((section, index) => {
        const content = section.querySelector('.section-content');
        // first section: keep background fixed, fade content as we scroll away
        if (index === 0) {
          section.style.transform = 'translateY(0)'; // background stays put
          const fadeProgress = clamp(scrollTop / SECTION_HEIGHT, 0, 1);
          if (content) content.style.opacity = String(Math.max(0, 1 - fadeProgress * 0.95));
          return;
        }

        const sectionStart = (index - 1) * SECTION_HEIGHT;
        const sectionEnd = index * SECTION_HEIGHT;

        // before we reach the section: keep it positioned below viewport
        if (scrollTop < sectionStart) {
          section.style.transform = 'translateY(100vh)';
          return;
        }

        // while the section is sliding up into view
        if (scrollTop >= sectionStart && scrollTop <= sectionEnd) {
          const slideProgress = clamp((scrollTop - sectionStart) / SECTION_HEIGHT, 0, 1);
          const translateY = (1 - slideProgress) * 100; // vh
          section.style.transform = `translateY(${translateY}vh)`;

          // fade ONLY the previous section's content (so the previous background stays intact)
          const prevContent = sections[index - 1].querySelector('.section-content');
          if (prevContent) prevContent.style.opacity = String(Math.max(0, 1 - slideProgress * 0.95));

          // incoming section content stays visible
          if (content) content.style.opacity = '1';
          return;
        }

        // fully in view
        if (scrollTop > sectionEnd) {
          section.style.transform = 'translateY(0)';
          if (content) content.style.opacity = '1';
        }
      });

      // hide hint after some scroll
      scrollIndicator.style.opacity = (scrollTop > 100 ? '0' : '1');

      // subtle parallax on shapes (none remain, but kept for completeness if added later)
    //   document.querySelectorAll('.bg-shape').forEach((shape, i) => {
    //     const speed = (i + 1) * 0.04;
    //     shape.style.transform = `translateY(${-(scrollTop * speed)}px)`;
    //   });
    }

    function initPositions() {
      SECTION_HEIGHT = window.innerHeight * 1.2;
      sections.forEach((s, i) => {
        if (i === 0) {
          s.style.transform = 'translateY(0)';
        } else {
          s.style.transform = 'translateY(100vh)';
        }
        const c = s.querySelector('.section-content');
        if (c) c.style.opacity = '1';
      });
    }

    // Initialize particle system for the first section only
    const drawerCanvas = document.getElementById('drawerHeroCanvas');
    let drawerParticleSystem = null;
    if (drawerCanvas) {
      drawerParticleSystem = new DrawerParticleSystem(drawerCanvas);
    }

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', () => { initPositions(); handleScroll(); });

    initPositions();
    handleScroll();
  </script>
</body>
</html>
